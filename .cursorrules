# infinity-node Cursor Configuration

## Project Context

**What is this project?**
infinity-node is a Proxmox-based home server infrastructure running containerized services across multiple VMs. The project manages a complete media server stack (Emby, *arr services, download clients) along with supporting services (Vaultwarden, Paperless-NGX, Immich, etc.).

**Primary goals:**
1. Document everything about the setup
2. Maintain reliable services (especially critical media services)
3. Automate deployment, updates, and recovery
4. Learn and improve processes over time

**Infrastructure:**
- **Hypervisor:** Proxmox VE at 192.168.1.81
- **VMs:**
  - VM 100 (emby): Media streaming - CRITICAL
  - VM 101 (downloads): Download clients with VPN - CRITICAL
  - VM 102 (arr): Media automation (*arr services) - CRITICAL
  - VM 103 (misc): Supporting services - Important
- **Storage:** 57TB Synology NAS (192.168.1.80) via NFS
- **External Access:** Pangolin tunnels for secure remote access

## Agent System

This project uses a **specialized agent system** where different agents handle specific domains. Each agent has defined responsibilities, permissions, and restrictions.

**Available Agents:**
- **Testing Agent** - Read-only validation and quality assurance
- **Docker Agent** - Container orchestration and stack management
- **Infrastructure Agent** - Proxmox, VMs, networking, storage
- **Security Agent** - Secrets, tunnels, VPN, security practices
- **Media Stack Agent** - Emby, *arr services, downloads (CRITICAL services)
- **Documentation Agent** - Knowledge management, MDTD tasks, runbooks

**Agent coordination:**
Complex tasks require multiple agents working together. For example, deploying a new service involves Documentation (create task), Security (setup secrets), Docker (create compose), Infrastructure (check resources), Testing (validate), and Documentation (document) agents.

**Full details:** See `docs/agents/README.md`

## MDTD Task Management

All significant work is tracked via **Markdown Task-Driven Development (MDTD)**:

- **Task files:** Markdown files in `tasks/` with frontmatter metadata
- **Task IDs:** Sequential format `IN-NNN` (e.g., IN-001, IN-024)
- **Lifecycle:** `backlog/` ‚Üí `current/` ‚Üí `completed/`
- **Priority:** Numeric 0-9 (0=critical, 1-2=high, 3-4=medium, 5-6=low, 7-9=very low)
- **Pre-task review:** Before starting non-trivial tasks, conduct critical analysis to identify gaps, risks, and improvements

**Task workflow summary:**

*When starting:*
1. Update status to `in-progress` in frontmatter
2. Move task from `backlog/` to `current/` (use `git mv`)
3. üö® **DO NOT COMMIT** - All commits happen at end only
4. Begin work on task phases

*During execution:*
5. üö® **Check off execution plan items IN REAL-TIME** as each phase completes (REQUIRED)
6. Check off acceptance criteria as completed
7. After each phase: pause, reflect, add notes to work log
8. Document decisions, discoveries, and any needed changes
9. üö® **Document lessons learned as you go** - capture important learnings that could affect future work

*When work complete:*
10. **DO NOT mark complete immediately**
11. üö® **DO NOT COMMIT** - Wait for user approval first
12. Present work to user for review and approval

*After approval - Lessons Learned Review:*
13. Review lessons learned section - what affects future work?
14. Decide on documentation updates needed
15. Decide on follow-up tasks needed
16. Present review findings to user for approval

*Finalize task:*
17. After review approval: mark complete, `git mv` to `completed/`, stage changes
18. üö® **VERIFY** with `git status` - check for lingering task files in wrong folders, clean up if found
19. **ASK to commit** all work

**Full details:** See `docs/AI-COLLABORATION.md` sections on MDTD

## Critical Services - Safety First

**CRITICAL services that affect household users:**
- **Emby** (VM 100): Primary media streaming - 99.9% uptime target
- **Downloads** (VM 101): Active downloads must not corrupt
- **arr services** (VM 102): Media automation pipeline must stay active

**Safety requirements for critical services:**
- ‚ö†Ô∏è Test in non-production when possible
- ‚ö†Ô∏è Always backup configurations before changes
- ‚ö†Ô∏è Deploy during low-usage windows (3-6 AM preferred)
- ‚ö†Ô∏è Have rollback plan ready
- ‚ö†Ô∏è Monitor closely after changes
- ‚ö†Ô∏è Coordinate with Testing Agent for validation

## Security Guidelines

**Secrets Management:**
- **NEVER commit secrets to git** (passwords, API keys, tokens, credentials)
- **Source of truth:** Vaultwarden instance on VM 103 (192.168.1.103:8111)
- **Storage pattern:** `.env` files on VMs (gitignored), `.env.example` in git
- **Access:** Bitwarden CLI for automation, web UI for manual management
- **Full details:** See `docs/SECRET-MANAGEMENT.md`

**Secret workflow:**
1. Store all secrets in Vaultwarden
2. Retrieve via Bitwarden CLI or web UI
3. Create `.env` files on VMs
4. Never commit actual secret values

**SSH Access:**
- **Proxmox:** `root@192.168.1.81`
- **VMs (full access):** `evan@<VM_IP>` (passwordless sudo for automation)
- **VMs (read-only):** `inspector@<VM_IP>` (Testing Agent only, policy-enforced)

## Git Workflow

**üö® CRITICAL RULES - READ BEFORE EVERY TASK:**
- **NEVER commit without explicit user approval** - Always ask first
- **NEVER push without explicit user approval** - Always ask first
- **NEVER commit during task execution** - Only commit at the very end after user approval
- **NO intermediate commits** - All task work commits together in one commit
- Use conventional commit format for messages
- Reference task IDs in commits (e.g., "Addresses IN-024")
- Commit logical units of work
- Review changes before committing

**Why This Matters:**
- User reviews ALL work before it's committed
- Intermediate commits break the review workflow
- Clean git history, not cluttered with partial work
- If you commit early, user will make you back it out

**What NEVER goes in git:**
- Secrets (passwords, API keys, tokens)
- `.env` files (use `.env.example` templates)
- Backup files
- Obsidian workspace files
- Session tokens

## Communication Style

**Do:**
- Be clear and concise
- Explain reasoning for recommendations
- Ask questions when unclear
- Admit when uncertain
- Suggest alternatives
- Challenge assumptions respectfully
- Work as co-workers, not boss/assistant

**Don't:**
- Use emojis (unless explicitly requested)
- Be overly formal or deferential
- Make assumptions about requirements
- Proceed with destructive operations without confirmation

## Obsidian Vault Structure

**This repository is an Obsidian vault:**
- Use wiki-links: `[[DOCKER]]` not `[Docker](DOCKER.md)`
- All documentation includes frontmatter for Dataview queries
- Works without Obsidian but enhanced with it

**Documentation patterns:**
- `docs/` - Project-wide documentation (architecture, agents, runbooks)
- `.docs/` - Context-specific documentation alongside code
- Use `.docs/` when documentation only relevant to one directory

## Key Files to Reference

**Core documentation:**
- `docs/AI-COLLABORATION.md` - Complete AI collaboration guide and workflows
- `docs/agents/README.md` - Agent system details
- `docs/ARCHITECTURE.md` - Infrastructure architecture and topology
- `docs/SECRET-MANAGEMENT.md` - Secret management practices
- `docs/DECISIONS.md` - Architectural decisions

**Operational:**
- `tasks/DASHBOARD.md` - Task overview and priorities
- `scripts/README.md` - Available automation scripts
- `stacks/README.md` - Docker stack overview

**Agent specifications:**
- `docs/agents/TESTING.md` - Testing Agent (read-only validation)
- `docs/agents/DOCKER.md` - Docker Agent (container orchestration)
- `docs/agents/INFRASTRUCTURE.md` - Infrastructure Agent (Proxmox, VMs)
- `docs/agents/SECURITY.md` - Security Agent (secrets, tunnels)
- `docs/agents/MEDIA.md` - Media Stack Agent (critical services)
- `docs/agents/DOCUMENTATION.md` - Documentation Agent (knowledge management)

## Tool Usage

**Preferred tools:**
- Use specialized file tools (read_file, search_replace, write) not terminal commands
- Use grep tool for searching, not bash grep
- Use glob_file_search for finding files by pattern
- Reserve terminal for actual system commands (SSH, git, docker)
- Never use terminal commands to communicate with user

**SSH patterns:**
- Run commands via SSH, don't maintain sessions
- Combine related commands with `&&`
- Use absolute paths when possible

**Bitwarden CLI:**
- **BEFORE asking user**: Check if session exists with `cat ~/.bw-session 2>/dev/null`
- If session exists (non-empty output), use it directly
- If no session: Ask user to run `./scripts/utils/get-bw-session.sh`
- Prefix EVERY `bw` command with `BW_SESSION="<token>"` (shells don't persist)
- Never attempt `bw` commands without valid session

## Docker & Portainer Usage

**‚ö†Ô∏è CRITICAL: All Docker stacks are managed via Portainer with Git integration**

**Use Portainer API for container operations:**
- ‚úÖ **Stack deployments**: Use Portainer API or UI (Git pull + redeploy)
- ‚úÖ **Stack updates**: Commit to git, then redeploy via Portainer
- ‚úÖ **Stack restarts**: Use Portainer API
- ‚ùå **NEVER use manual docker-compose commands** for deployments/updates
- ‚úÖ **Read-only queries OK**: `docker ps`, `docker logs`, `docker inspect`

**Deployment workflow:**
```bash
# 1. Update docker-compose.yml in git
git add stacks/SERVICE/docker-compose.yml
git commit -m "update: SERVICE configuration"

# 2. Deploy via Portainer API
./scripts/infrastructure/redeploy-git-stack.sh \
  --secret "portainer-api-token-vm-XXX" \
  --stack-name "SERVICE"

# OR use Portainer UI: Stacks ‚Üí SERVICE ‚Üí "Pull and redeploy"
```

**Why Portainer?**
- All stacks are Git-integrated (single source of truth)
- Portainer handles secret injection, environment setup
- Consistent deployment across all VMs
- Avoids manual docker-compose drift

## Service Organization

**Directory structure:**
```
infinity-node/
‚îú‚îÄ‚îÄ docs/           # Documentation
‚îú‚îÄ‚îÄ tasks/          # MDTD task management
‚îú‚îÄ‚îÄ stacks/         # Docker compose configurations
‚îú‚îÄ‚îÄ scripts/        # Automation scripts
‚îú‚îÄ‚îÄ ansible/        # Configuration management
‚îî‚îÄ‚îÄ config/         # Configuration templates
```

**Stack pattern:**
Each service has:
- `docker-compose.yml` - Service definition (Git-integrated with Portainer)
- `.env.example` - Template for secrets
- `README.md` - Service documentation

## Best Practices

**Before starting task:**
1. Read the task completely if working from MDTD
2. Conduct pre-task review for non-trivial work
3. **Update task status to `in-progress`**
4. **Move to `current/` with `git mv`**
5. üö® **DO NOT COMMIT YET** - Only commit at end
6. Identify which agent(s) should handle the work
7. Check if critical services are affected
8. Plan rollback strategy if needed

**During task execution:**
9. üö® **Check off execution plan items IN REAL-TIME** as each phase completes (REQUIRED)
10. **Check off acceptance criteria as completed**
11. **After each phase: pause, reflect, add notes to work log**
12. Document decisions and discoveries as work progresses
13. üö® **Document lessons learned as you go** - capture important learnings that could affect future work
14. Suggest changes if new information warrants it
15. Test changes thoroughly
16. Coordinate with Testing Agent for validation
17. üö® **DO NOT COMMIT during execution** - Wait for approval

**When task work is complete:**
18. **Present work to user for review (DO NOT mark complete yet)**
19. üö® **DO NOT COMMIT** - Wait for approval first
20. Wait for user approval

**After approval - Lessons Learned Review:**
21. **Review lessons learned section** - what affects future work?
22. **Decide on documentation updates** needed (runbooks, ADRs, etc.)
23. **Decide on follow-up tasks** needed
24. **Present review findings** to user for approval

**Finalize task:**
25. After review approval: mark complete, `git mv` to `completed/`, stage changes
26. üö® **VERIFY** with `git status` - check for lingering task files in wrong folders, clean up if found
27. **ASK to commit** all work

## Success Criteria

- Critical services maintain 99.9% uptime
- All infrastructure documented
- Changes tracked via MDTD
- Secrets never in git
- Automation simplifies management
- Knowledge captured for future

---

**Remember:** We're building this together. Question assumptions, suggest improvements, and work as partners to create great infrastructure!
